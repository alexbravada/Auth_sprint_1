Ссылка на проект https://github.com/alexbravada/Auth_sprint_1
Участники @npocbet, @paQQuete, @alexbravada
# Проектная работа 6 спринта

## Взаимодействие с другими сервисами

Сервис аутентификации выдает клиентскому приложению JWT токены. Эти токены используются для аутетификации в других
сервисах, например сервис [API](https://github.com/alexbravada/Async_API_sprint_2). Для аутентификации в этом
сервисе API необходимо указать Bearer токен в заголовке Authorization, токен будет провалидирован самим сервисом.
Второй токен часто передаётся в теле запроса например: {"access_token": "jwt"}


## Запуск проекта:

1. Создаем файл .env на основе .env_example (копируем и редактируем)
2. Запускаем создание докер-образа:

```
docker-compose up --build  
```


3. ОПЦИОНАЛЬНО: Создаем суперпользователя. Нужно зайти в контейнер с Flask и запустить консольную команду (не забудьте
   указать свой емэйл и пароль)

```
docker exec -it auth_sprint_1 bash
python3 -m flask create-superuser your@email.com yourpassword123
```

## Особенности проекта
```
- В проекте {"is_admin": True/False} прописывается в JWT payload, по умолчанию в БД проставляется False
- Интеграция поиска и Auth сервиса подразумевает обработку запросов через приватные ручки API (api/v1/private) и проверку роли пользователя на наличие прав на ресурс (фильм, комментарий, и т.д.), которые содержатся в модели ResourceRole(resource__role). 
По умолчанию все пользователи создаются с дефолтной ролью (id роли прописывается в JWT), которая запрещает любое взаимодействие с ресурсами. 
Для наполнения таблицы resource будет сделан ETL процесс, который копирует все uuid фильмов и в эту же таблицу заносятся любые другие ресурсы, к которым нужно будет проверять доступ. Так будет реализовываться взаимодействие поискового сервиса и сервиса Auth. 
Изящная деградация реализована простым путём - при проверке прав на ручке /api/v1/private/check_permissions отдаются аргументы из запроса и дефолтные права (т.е. на время падения Auth сервиса или БД все клиенты поиска ненадолго возьмут себе дефолтную роль).
Контракт (OpenAPI 3.0) размещён в /src/api/v1/private/schema.yml

```

# Список endpoints

Для тестирования через [OpenAPI] необходимо перейти по адресу:

```
http://localhost/
```

Представленные enpoints:

Управление ролями:

- Получение списка ролей: **GET /api/v1/auth/role**
- Создание роли: **POST /api/v1/auth/role/add**
- Удаление роли: **DELETE /api/v1/user/auth/role/delete**
- Получение роли по идентификатору: **GET /api/v1/auth/role/<int:role_id>**
- Изменение роли по ее идентификатору в теле зарпоса: **PATCH /api/v1/auth/role/update**

Управление авторизацией:

- Авторизация пользователя: **POST /api/v1/auth/user/signin**
- Создание пользователя: **POST /api/v1/auth/user/signup**
- Подтверждение валидности access tokena: - **POST /api/v1/auth/user/access**
- Выход пользователя (помещает переданные токены в блоклист): **POST /api/v1/auth/user/logout**
- Для валидного refresh-токена возвращает пару токенов access+refresh: **POST /api/v1/auth/refresh**

Авторизация через OAuth2:

- Получение кода авторизации через Yandex: **GET /api/v1/oauth/authorize/yandex**
- Получение кода авторизации через Google: **GET /api/v1/oauth/authorize/google**
- Получение кода авторизации через VK: - **GET /api/v1/oauth/authorize/vk**
- Обмен кода в **/callback** на **access_token & refresh_token происходит внутри сервиса авторизации**
- Обращение к **GET /api/v1/oauth/authorize/<oauth_service_name> возвращает 2 токена.**

Управление пользователями:

- Обновление логина и пароля пользователя: **PATCH /api/v1/auth/user/**
- История авторизаций пользователя: **GET /api/v1/auth/user/auth_history**
- Удаление роли у пользователя: **DELETE /api/v1/auth/user/role/user_role_delete**
- Получение списка ролей одного пользователя **GET /api/v1/auth/user/role/user_role_show/<int:user_id>**
- Добавление роли пользователя **POST /api/v1/auth/user/role/user_role_add**

